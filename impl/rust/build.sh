#!/bin/bash
set -e

# Configuration
IDS_DIR="../../ids"
BINS_DIR="../../bins"
OUTPUT_FILE="src/constants.rs"

# Generate enum implementation
generate_enum_impl() {
    local csv_file="$1"
    local enum_name="$2"

    cat << EOF
impl $enum_name {
    pub fn from_id(id: u8) -> Self {
        match id {
$(awk -F, 'NR>1 {gsub(/\r/,""); if ($3 != "" && $3 !~ /\*/) printf "            %s => Self::%s,\n", $1, $3}' "$csv_file")
            _ => Self::$(awk -F, 'NR==2 {print $3}' "$csv_file"), // Default
        }
    }
}

EOF
}

# Generate enum definition
generate_enum() {
    local csv_file="$1"
    local enum_name="$2"

    cat << EOF
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum $enum_name {
$(awk -F, 'NR>1 {gsub(/\r/,""); if ($3 != "" && $3 !~ /\*/) printf "    %s = %s,\n", $3, $1}' "$csv_file")
}

EOF
}

# Generate data constants using compact macro
generate_data_constant() {
    local file="$1"
    local filename_base=$(basename "$file" .csv)
    local const_name=$(echo "$filename_base" | tr '-' '_' | tr '[:lower:]' '[:upper:]')_DATA

    cat << EOF
/// $filename_base data: (id, name_lowercase, aliases_lowercase)
pub static $const_name: &[DataEntry] = &[
$(awk -F, 'NR>1 {
    gsub(/\r/,"");
    gsub(/"/,"");
    if ($2 != "" && $2 !~ /\*/) {
        name_lower = tolower($2);

        aliases_lower = "";
        if (NF >= 3 && $3 != "") {
            # Process aliases separated by |
            split($3, alias_array, "|");
            alias_results = "";
            for (i in alias_array) {
                alias = tolower(alias_array[i]);
                gsub(/[^a-z0-9]/,"", alias);
                if (alias != "" && alias != name_lower) {
                    if (alias_results != "") alias_results = alias_results "|";
                    alias_results = alias_results alias;
                }
            }
            aliases_lower = alias_results;
        }

        printf "    entry!(%s, \"%s\", \"%s\"),\n", $1, name_lower, aliases_lower
    }
}' "$file")
];

EOF
}

# Generate convenience functions for each data type
generate_convenience_functions() {
    local file="$1"
    local filename_base=$(basename "$file" .csv)
    local const_name=$(echo "$filename_base" | tr '-' '_' | tr '[:lower:]' '[:upper:]')_DATA
    local function_name=$(echo "$filename_base" | tr '-' '_')

    cat << EOF
/// Find ${filename_base//-/ } by name or alias
pub fn resolve_${function_name}(query: &str) -> Option<&'static DataEntry> {
    Resolver::find_by_name($const_name, query)
}

/// Find ${filename_base//-/ } by ID
pub fn ${function_name}_by_id(id: u64) -> Option<&'static DataEntry> {
    Resolver::find_by_id($const_name, id)
}

EOF
}

# Generate bins data
generate_bins() {
    cat << 'EOF'
pub static BINS: LazyLock<HashMap<BinAggregator, [f64; 128]>> = LazyLock::new(|| {
    let mut main_map = HashMap::new();
EOF

    for file in "$BINS_DIR"/*.csv; do
        local filename=$(basename "$file" .csv)
        local aggregator_name=$(echo "$filename" | sed 's/-/_/g' | tr '[:lower:]' '[:upper:]')
        cat << EOF
    let bins = [
$(awk -F, 'NR>1 {gsub(/\r/,""); printf "        %s,\n", $2}' "$file")
    ];
    main_map.insert(BinAggregator::$aggregator_name, bins);
EOF
    done

    cat << 'EOF'
    main_map
});
EOF
}

# --- Main Generation ---
cat > "$OUTPUT_FILE" << 'HEADER'
// This file is generated by build.sh. DO NOT EDIT.
use std::collections::HashMap;
use std::sync::LazyLock;

/// Compact macro for DataEntry creation
macro_rules! entry {
    ($id:expr, $name:expr, $aliases:expr) => {
        DataEntry {
            id: $id,
            name: $name,
            aliases: $aliases,
        }
    };
}

HEADER

# Generate enums
for enum_file in asset-classes instrument-types; do
    csv_file="$IDS_DIR/$enum_file.csv"
    # Generate singular enum names: AssetClass, InstrumentType
    if [[ "$enum_file" == "asset-classes" ]]; then
        enum_name="AssetClass"
    else
        enum_name="InstrumentType"
    fi

    generate_enum "$csv_file" "$enum_name" >> "$OUTPUT_FILE"
    generate_enum_impl "$csv_file" "$enum_name" >> "$OUTPUT_FILE"
done

# BinAggregator enum
cat >> "$OUTPUT_FILE" << 'BINAGG'
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum BinAggregator {
BINAGG

for file in "$BINS_DIR"/*.csv; do
    filename=$(basename "$file" .csv)
    aggregator_name=$(echo "$filename" | sed 's/-/_/g' | tr '[:lower:]' '[:upper:]')
    echo "    $aggregator_name," >> "$OUTPUT_FILE"
done

cat >> "$OUTPUT_FILE" << 'DATASTRUCT'
}

/// Standardized data entry: (id, name_lowercase, aliases_lowercase)
#[derive(Debug, Clone)]
pub struct DataEntry {
    pub id: u64,
    pub name: &'static str,
    pub aliases: &'static str,
}

DATASTRUCT

# Generate data constants
for file in "$IDS_DIR"/*.csv; do
    filename_base=$(basename "$file" .csv)
    if [[ "$filename_base" =~ ^(asset-classes|instrument-types)$ ]]; then continue; fi
    generate_data_constant "$file" >> "$OUTPUT_FILE"
done

# Generic resolver
cat >> "$OUTPUT_FILE" << 'RESOLVER'
/// Generic resolver that searches both names and aliases
#[derive(Debug)]
pub struct Resolver;

impl Resolver {
    /// Find entity by name or alias (case-insensitive, normalized)
    pub fn find_by_name<'a>(data: &'a [DataEntry], query: &str) -> Option<&'a DataEntry> {
        let normalized_query = Self::normalize(query);

        data.iter().find(|entry| {
            // Check name match
            if entry.name == normalized_query {
                return true;
            }

            // Check aliases match
            if !entry.aliases.is_empty() {
                for alias in entry.aliases.split('|') {
                    if alias == normalized_query {
                        return true;
                    }
                }
            }

            false
        })
    }

    /// Find entity by ID
    pub fn find_by_id<'a>(data: &'a [DataEntry], id: u64) -> Option<&'a DataEntry> {
        data.iter().find(|entry| entry.id == id)
    }

    /// Normalize string for comparison (lowercase, alphanumeric only)
    fn normalize(input: &str) -> String {
        input.to_lowercase().chars().filter(|c| c.is_alphanumeric()).collect()
    }
}

RESOLVER

# Generate convenience functions
for file in "$IDS_DIR"/*.csv; do
    filename_base=$(basename "$file" .csv)
    if [[ "$filename_base" =~ ^(asset-classes|instrument-types)$ ]]; then continue; fi
    generate_convenience_functions "$file" >> "$OUTPUT_FILE"
done

# Generate bins
generate_bins >> "$OUTPUT_FILE"

echo "Generated src/constants.rs with unified structure and generic resolver"
